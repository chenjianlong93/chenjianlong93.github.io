## OSI七层模型和协议
当今互联网世界能够正常运行，得益于各个软、硬件厂商严格遵守现有的网络通信相关的协议。而OSI（Open System Interconnection）就是由国际标准化组织制定的一个模型。该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本架构。

OSI模型把网络通信的工作分为7层，分别是`物理层、数据链路层、网络层、传输层、会话层、表示层和应用层`

![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=bfafd35da918972bb737089887a410ec/6a600c338744ebf875f58b76dbf9d72a6159a7f7.jpg)

对于客户端来说，我们比较关注的是传输层和应用层相关的协议。例如传输层的TCP/UDP协议，以及应用层的HTTP/HTTPS协议。所以，本文讨论的重点就是这两层。

## 传输层协议

顾名思义，传输层主要作用是**实现应用程序之间额通信**，常见的传输层协议有TCP、UDP。

### TCP协议

TCP协议是面向有连接的协议，也就是说在使用TCP协议传输数据之前一定要在发送发和接收方建立连接。一般情况下建立连接需要三步，关闭连接需要四步。

建立TCP连接后，由于有`数据重传、流量控制`等功能，TCP协议可以正确处理丢包问题，保证接收方能够收到数据。但是TCP协议中制定了许多复杂的规范，因此效率不如UDP协议，不适合实时的视频和音频传输。

> TCP首部

TCP首部的设计要比UDP复杂得多。解析这个首部的时间也会相应增加。这也是TCP连接的效率低于UDP的原因之一。

![](https://raw.githubusercontent.com/zrysmt/mdPics/master/HTTP%E5%8D%8F%E8%AE%AE/tcp-ip/16.png)

其中某些关键字段解释如下：

* 序列号：它表示发送数据的位置，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。
* 确认应答号：它等于下一次应该接收到的数据的序列号。假设发送端的序列号为 s，发送数据的长度为 l，那么接收端返回的确认应答号也是 s + l。发送端接收到这个确认应答后，可以认为这个位置以前所有的数据都已被正常接收。
* 数据偏移：TCP 首部的长度，单位为 4 字节。如果没有可选字段，那么这里的值就是 5。表示 TCP 首部的长度为 20 字节。
* 控制位：改字段长度为 8 比特，分别有 8 个控制标志。依次是 CWR，ECE，URG，ACK，PSH，RST，SYN 和 FIN。
* 窗口大小：用于表示从应答号开始能够接受多少个 8 位字节。如果窗口大小为 0，可以发送窗口探测。
* 紧急指针：尽在 URG 控制位为 1 时有效。表示紧急数据的末尾在 TCP 数据部分中的位置。通常在暂时中断通信时使用（比如输入 Ctrl + C）。

> TCP 握手

TCP是面向有连接的协议，连接在每次通信被建立之前，通信结束后被关闭。连接的建立和关闭如下图：

![](https://raw.githubusercontent.com/zrysmt/mdPics/master/HTTP%E5%8D%8F%E8%AE%AE/tcp-ip/20.jpg)

可以看出，TCP通过三次握手建立连接：
1. （客户端）：我要建立连接了。
2. （服务端）：我知道你要建立连接了，我这边没有问题。
3. （客户端）：我知道你知道我要建立连接了，接下来我们就正式开始通信。

**为什么是三次握手？少一次握手会怎样？**

按照正常思维，我们可能会觉得两次握手就行了，第三步是多余的。那为什么TCP协议还要费力地加上这次握手呢？

这是因为在网络请求中，我们应该时刻记住：**网络是不可靠的，数据包是可能丢失的**。假设没有第三次确认，会发生怎样的异常：

1. 客户端向服务端发送了SYN，请求建立连接。由于延迟，服务端并未及时收到。
2. 这时客户端又会重新发送一个SYN包，服务器接收了第二个SYN包，建立了通信，一段时间后通信结束。
3. 此时，第一次发送的SYN包抵达，服务端又会发送一次ACK确认。由于两次握手就能建立连接，此时就会建立一个新的空的连接，白白浪费资源。
4. 而在三次握手才能建立连接的情况下，服务端知道接收到客户端的应答才会建立连接。因此在上述情况下，客户端会接收到一个相同的来自服务端的ACK包，这时它会抛弃这个数据包，不会建立空的连接。

**ACK确认应答的包丢失怎么办？**

三次握手解决了第二步数据包的问题，那第三步丢失后，TCP是怎样处理的呢？

按照 TCP 协议处理丢包的一般方法，服务端会重新向客户端发送数据包，直至收到 ACK 确认为止。但实际上这种做法有可能遭到 SYN 泛洪攻击。所谓的泛洪攻击，是指发送方伪造多个 IP 地址，模拟三次握手的过程。当服务器返回 ACK 后，攻击方故意不确认，从而使得服务器不断重发 ACK。由于服务器长时间处于半连接状态，最后消耗过多的 CPU 和内存资源导致死机。

正确处理方法是服务端发送 RST 报文，进入 CLOSE 状态。这个 RST 数据包的 TCP 首部中，控制位中的 RST 位被设置为 1。这表示连接信息全部被初始化，原有的 TCP 通信不能继续进行。客户端如果还想重新建立 TCP 连接，就必须重新开始第一次握手。

**四次握手关闭连接**

1. （客户端）：我要关闭连接了。
2. （服务端）：你那边的连接可以关闭了。
3. （服务端）：我这边也要关闭连接了。
4. （客户端）：你那边的连接可以关闭了。

**关闭连接的最后一个 ACK 丢失怎么办**

实际上，在第三步中，客户端收到 FIN 包时，它会设置一个计时器，等待相当长的一段时间。如果客户端返回的 ACK 丢失，那么服务端还会重发 FIN 并重置计时器。假设在计时器失效前服务器重发的 FIN 包没有到达客户端，客户端就会进入 CLOSE 状态，从而导致服务端永远无法收到 ACK 确认，也就无法关闭连接。

### UDP协议

UDP协议是面向无连接的协议，它只会把数据传递给接收端，但不会关注接收端是否接收到了数据。但这种特性反而适合实时的音频、视频传输，因为个别少数数据包的丢失并不会影响视频音频的整体效果，如果用TCP的话，由于效率低反应慢造成延时的效果反而不好。

> UDP首部

![](http://upload-images.jianshu.io/upload_images/1868951-80b631d1cdcf682a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 源端口号: 标识发送端端口号,字段长16位。该字段可以不设置,缺省值为0,可用于不需要返回的通信中。
* 目标端口号: 标识接收端端口号,字段长16位。
* 包长度: 指UDP首部的长度和数据的长度之和。为8位字节。
* 检验和: 校验和用来判断数据在传输过程中是否损坏。计算这个校验和的时候，不仅考虑源端口号和目标端口号，还要考虑 IP 首部中的源 IP 地址，目标 IP 地址和协议号（这些又称为 UDP 伪首部）。这是因为以上五个要素用于识别通信时缺一不可，如果校验和只考虑端口号，那么另外三个要素收到破坏时，应用就无法得知。这有可能导致不该收到包的应用收到了包，改收到包的应用反而没有收到。

### TCP、UDP区别总结
TCP：面向数据流，有连接，三次握手建立连接，四次握手断开连接。传输可靠（保证数据正确性且保证数据顺序）、速度慢、建立连接需要开销多（时间、资源）。
UDP：面向数据包，无连接，传输不可靠，但是耗费资源少，速度快。通常像音频、视频这类数据都采用UDP，因为个别少数数据包的丢失并不会影响视频音频的整体效果，如果用TCP的话，由于效率低反应慢造成延时的效果反而不好。

### Socket套接字
使用TCP或UDP时，会广泛用到套接字（Socket）的API。应用程序利用套接字，可以设置对端的IP地址、端口号，并实现数据的发送与接收。

数据链路和IP中的地址,分别指的是MAC地址和IP地址。
前者用来识别同一链路中不同的计算机,后者用来识别TCP/IP网络中互连的主机和路由器。
同样的,在传输层中也有类似于地址的概念,那就是端口号。
端口号用来识别同一台计算机中进行通信的不同应用程序。因此,它也被称为程序地址。

![](http://upload-images.jianshu.io/upload_images/1868951-afc4629f1a207553.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

仅凭目标端口识别某一个通信是远远不够的。通常采用5个信息来识别一个通信。它们分别是:
* 源IP地址
* 目标IP地址
* 协议号 :在IP协议部分我们提到IP首部中有一个协议字段,用来标识网络层(IP)的上层所采用的是哪一种传输层协议。根据这个字段的协议号,就可以识别IP传输的数据部分究竟是TCP的内容,还是UDP的内容。
* 源端口号
* 目标端口号

**TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）或插口。**

套接字，是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

非常非常简单的举例说明下:Socket=Ip address+ TCP/UDP + port。

## 应用层协议（HTTP/HTTPS）
### HTTP 协议概述
在OSI七层协议中，HTTP协议位于最顶层的应用层。我们平常用浏览器访问网页就直接使用了HTTP协议。使用HTTP协议时，客服端会首先与服务端的80端口建立一个TCP连接，然后在此基础上进行请求和应答，以及数据的传输。

![](https://upload-images.jianshu.io/upload_images/2049501-f2058a2ca1c3ff2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

HTTP 有两个常用版本，分别是 1.0 和 1.1。主要区别在于 HTTP 1.0 中每次请求和应答都会使用一个新的 TCP 连接，而从 HTTP 1.1 开始，运行在一个 TCP 连接上发送多个命令和应答。因此大幅度减少了 TCP 连接的建立和断开，提高了效率。

由 HTTP 协议加载出来的网页，通常使用 HTML 语言来描述，因此 HTML 也可以理解为网页的一种数据格式。

### POST 请求和 GET 请求
HTTP 有八种请求（也称方法），其中最常见的是 GET 请求和 POST 请求。

GET和POST有以下不同：
1. GET 请求可以被缓存，可以被收藏为书签，但 POST 不行。
2. GET 请求会保留在浏览器的历史记录中，POST 不会。
3. GET 请求的长度有限制（不同的浏览器不一样，大约在几 Kb 左右），URL 的数据类型只能是 ASCII 字符，POST 请求没有限制。
4. GET 请求的参数在 URL 中，因此绝不能用 GET 请求传输敏感数据。POST 请求数据则写在 HTTP 的请求头中，安全性略高于 GET 请求。

**POST 请求仅比 GET 请求略安全一点，它的数据不在 URL 中，但依然以明文的形式存放于 HTTP 的请求头中。**

### Cookie 和 Session
HTTP 是一种无状态的连接，客户端每次读取 web 页面时，服务器都会认为这是一次新的会话。但有时候我们又需要持久保持某些信息，比如登录时的用户名、密码，用户上一次连接时的信息等。这些信息就由 Cookie 和 Session 保存。

这两者的根本性区别在于，cookie 保存在客户端上，而 session 则保存在服务器中。由此我们还可以拓展出以下结论：
1. cookie 相对来说不安全，浏览器可以分析本地的 cookie 进行 cookie 欺骗。
2. session 可以设置超时时间，超过这个时间后就失效，以免长期占用服务端内存。
3. 单个 cookie 的大小有限制（4 Kb），每个站点的 cookie 数量一般也有限制（20个）。
4. 客户端每次都会把 cookie 发送到服务端，因此服务端可以知道 cookie，但是客户端不知道 session。

当服务器接收到 cookie 后，会根据 cookie 中的 SessionID 来找到这个客户的 session。如果没有，则会生成一个新的 SessionID 发送给客户端。

### 加密
加密分为两种，`对称加密和非对称加密`。

所谓的对称，就是指加密秘钥和解密秘钥相同，而非对称自然就是指两者不同。

举个对称加密的例子。假设这里的加密算法是加法，解密算法是减法。如果明文数据是 10，秘钥是 1，那么加密数据就是 10 + 1 = 11，如果接收方不知道秘钥，就不知道密文 11 应该减去几。反之，如果接收方知道秘钥是 1，就可以通过 11 - 1 = 10 计算出明文数据。

非对称加密算法比较常见的是RSA算法，主要利用了“两个素数求乘积容易，但是将乘积分解为两个素数很难”这一思想。

`在非对称加密中，利用公钥加密的数据能且只能通过私钥解密，通过私钥加密的数据能且只能通过公钥解密。`

一般我们把服务器自己留着，不对外公布的密钥称为私钥，所有人都可以获取的称为公钥。对称加密一般要比非对称加密快得多，对服务器的运算压力也小得多。

除此之外，加密方式还有`可逆加密和不可逆加密`之分。

可逆加密就是有加密也有解密，不可逆则只有加密没有解密。

不可逆加密方式最常用的就是哈希算法（如MD5），这种算法最大特点就是：它可以压缩数据，如果从函数角度来看，不管多复杂的数据(定义域可以非常大)经过哈希算法都会得到一个值，而且这个值处在某个特定(远小于定义域的范围)值域内。相同数据的哈希结果一定相同，不相同数据的哈希结果一般不同，不过也有小概率会重复，这叫哈希冲突。

通常用户的密码等私密信息都会通过客户端MD5加密之后上传给服务器，服务器存的都是加密后的字符串。

### HTTPS
我们知道 HTTP 协议直接使用了 TCP 协议进行数据传输。由于数据没有加密，都是直接明文传输，所以存在以下三个风险：

1. 窃听风险：第三方节点可以获知通信内容。
2. 篡改风险：第三方节点可以修改通信内容。
3. 冒充风险：第三方节点可以冒充他人身份参与通信。

比如你在手机上打开应用内的网页时，有时会看到网页底部弹出了广告，这实际上就说明你的 HTTP 内容被窃听、并篡改了。

HTTPS 协议旨在解决以上三个风险，因此它可以：

1. 保证所有信息加密传输，无法被第三方窃取。
2. 为信息添加校验机制，如果被第三方恶意破坏，可以检测出来。
3. 配备身份证书，防止第三方伪装参与通信。

HTTPS相比HTTP而言，仅仅是在HTTP和TCP之间新增了一个SSL/TLS的加密层。

![](http://images.cnitblog.com/kb/1/201401/05125746-760ce000eb624a4f9a7d0d1d0b71ec0a.png)

使用 HTTPS 时，服务端会将自己的证书发送给客户端，其中包含了服务端的公钥。基于非对称加密的传输过程如下：
1. 客户端使用公钥将信息加密，密文发送给服务端
2. 服务端用自己的私钥解密，再将返回数据用私钥加密发回客户端
3. 客户端用公钥解密

这里的证书是服务器证明自己身份的工具，它由权威的证书颁发机构（CA）发给申请者。如果证书是虚假的，或者是自己给自己颁发的证书，服务器就会不认可这个证书并发出警告。

**总结一下 HTTPS 协议是如何避免前文所说的三大风险的：**
1. 先用非对称加密传输密码，然后用这个密码对称加密数据，使得第三方无法获得通信内容
2. 发送方将数据的哈希结果写到数据中，接收方解密后对比数据的哈希结果，如果不一致则说明被修改。由于传输数据加密，第三方无法修改哈希结果。
3. 由权威机构颁发证书，再加上证书校验机制，避免第三方伪装参与通信。