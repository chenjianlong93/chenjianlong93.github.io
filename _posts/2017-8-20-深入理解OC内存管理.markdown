### 引用计数原理
OC语言使用引用计数原理来管理内存，也就是说，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，就递增琦引用计数；用完之后，就递减其计数。计数变为0，就没有人关注此对象了，也是就可以将其销毁。

在OC中，对象的计数器被称作引用计数（retain count）。NSObject协议声明了下面三个方法操作引用计数器，以递增或递减其值：

* retain	  递增引用计数
* release   递减引用计数
* autorelease 待稍后清理自动释放池（autorelease pool）时，再递减引用计数。稍后会讲到自动释放池在OC内存管理中的作用。

### 以ARC简化引用计数
ARC（automatic reference count）自动引用计数是苹果在iOS5引入的内存管理相关的特性。自动引用计数所做的事情与其名称相符，也就是自动管理引用计数。也就是编译器会在适当的时候自动为你加上对象的retain和release操作，不用程序员手动添加。所以在ARC下直接调用retain、release、autorelease是非法的。

> 使用ARC时必须遵循的方法命名规则

若方法以下列词语开头：alloc、new、copy、mutableCopy，调用者就要负责释放方法所返回的对象。

除了会自动调用retain和release外，ARC还有其他好处。它可以对程序完成很多优化。例如，在编译器如果发现在同一个对象上执行了多次retain和release操作，那么ARC就可以成对地移除这两个操作。

### 变量的内存管理语义
* strong：默认语义，保留新值，释放旧值
* unsafe_unretained：表示非拥有关系，既不保留新值又不释放旧值。从名字可以看出，这么做可能不安全，因为如果指针指向的内存已经被释放了，再次通过指针访问的话，就会造成悬停指针，内存被重写的话就会出现问题。此内存语义是在weak被引入之后被代替。
* weak：表示非拥有关系，既不保留新值又不释放旧值。用于OC对象，与unsafe_unretained作用相同，只是如果系统回收了这个对象，那么用weak修饰的变量指针也会被清空（nil out）。
* autoreleasing：把对象按引用传递给方法时，使用此特殊修饰符，此值在方法返回时自动释放。

**需要注意的是，ARC仅用于OC对象的内存管理，对于CoreFoundation对象、CoreGraphic对象则需要开发者自行调用retain/release方法（不释放的话会造成内存泄漏）**

### 自动释放池
说到OC内存管理，就不能不提autorelease。autorelease的作用是什么呢？顾名思义就是自动释放。我们知道如果局部变量在超出其作用域时在ARC下回自动调用release，回收该局部变量的内存。但是如果是以下情况：

```
-（NSSring *）stringValue {
 	NSString *str = [[NSString alloc] initWithFormat:@"I am this %@",self];
 	return str;
}
```
此时str已经超出了其所用域，但是又不是释放掉，因为调用者还需要用到str。在这种情况下就不能调用release，需要用autorelease代替。表明此方法会在稍后递减计数，通常是在下一次事件循环（event loop）时递减。（排除自动释放池嵌套的情况）

> 自动释放池与线程之间的关系

如果在没有创建自动释放池的情况下给对象发autorelease消息，那么程序会发生崩溃。

然而，一般情况下无无须担心自动释放池的创建问题。那是因为，系统会自动创建一些线程，比如说主线程或是GCD机制中的线程，这些线程默认都有自动释放池，每次这次runloop执行完毕到下一次runloop开始之前会将自动释放池里面的对象清空。我们iOS程序的主程序main函数外就被一个主线程的autoreleasepool所包裹。

> 自动释放池的应用
 
自动释放池是可以嵌套的，意味着尽管主线程外部已经被一个自动释放池所包裹，我们还是可以自己创建自动释放池。在@autoreleasepool{}范围里的对象，都将在此范围末尾处收到release消息。

也就是说，如果执行一个for循环，里面会创建大量的对象的时候，可以把for循环里面创建对象的操作嵌套一个自动释放池。这样就可以提早释放掉已经没用的临时对象的内存，达到降低内存的作用。

### 用僵尸对象调试内存管理问题

我们知道，向已经被回收的对象发消息是不安全的。这么做有时可以有时不行，具体是否会引发崩溃取决于该对象所占的内存是否已经被重写。因此，程序只是偶尔崩溃，所幸iOS提供了僵尸对象这个用于检测是否存在内存已经被回收但是依旧被访问的情况的功能。

> 僵尸对象的实现原理

简单来讲，就是runtime会将所有已经回收的实例转化为特殊的僵尸对象，而不会真正回收他们。这种对象不会被重用，因此不能被重写。僵尸对象收到消息后，会走完整的消息转发并抛出异常，准确说明发送过来的消息，并描述之前回收的那个对象，僵尸对象对于调试内存问题很有用。

具体步骤如下：
1. 将已经回收的对象特殊处理，并不会真正回收内存。因此不会被重写，只是因为调试手段导致的内存泄漏。
2. 如果对已经回收的对象发消息，runtime会修改对象的isa指针，另其指向特殊的僵尸类，通常类名是NSZombie_XXXClass。这样做的好处是能记录对象原来的类。
3. 由于特殊的僵尸类并未实现任何方法，因此会来到消息转发流程。在完整的消息转发过程中，forwarding函数会检查消息接受对象所属的类名。若前缀为NSZombie，则表明消息接受者是僵尸对象。此时会打印出对象所属类名以及对象内存这些信息。



